name: CI

on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string

jobs:
  build-test-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.set-app-version.outputs.app_version }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Display manual trigger info
        run: |
          echo "üöÄ Manual CI trigger initiated"
          echo "üìù Reason: ${{ inputs.reason || 'Manual testing' }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"

      - name: Set Build Info (job + run)
        id: set-build-info
        run: |
          BUILD_NAME="${{ github.event.repository.name }}-${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Set build variables
        run: |
          SERVICE_NAME=checkout
          IMAGE_TAG=$(echo $GITHUB_SHA | head -c7)
          REGISTRY_URL="${{ vars.DOCKER_REGISTRY }}"
          IMAGE_NAME="${REGISTRY_URL}/${{ vars.PROJECT_KEY }}-${SERVICE_NAME}-docker-internal-local/${SERVICE_NAME}:${IMAGE_TAG}"

          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "REGISTRY_URL=$REGISTRY_URL" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

      - name: Determine SemVer image version
        id: set-app-version
        run: |
          set -euo pipefail
          SERVICE_NAME=${SERVICE_NAME:-checkout}
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          echo "üîé Resolving next SemVer for $APPLICATION_KEY"
          RESP_FILE=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "Accept: application/json")
          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            if LATEST_VERSION=$(jq -er '.versions[0].version // empty' "$RESP_FILE" 2>/dev/null); then
              :
            else
              LATEST_VERSION=""
            fi
          else
            LATEST_VERSION=""
          fi
          rm -f "$RESP_FILE"
          if [[ -n "$LATEST_VERSION" && "$LATEST_VERSION" != "null" ]]; then
            MAJOR=$(echo "$LATEST_VERSION" | cut -d. -f1)
            MINOR=$(echo "$LATEST_VERSION" | cut -d. -f2)
            PATCH=$(echo "$LATEST_VERSION" | cut -d. -f3 | cut -d- -f1)
            APP_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
            echo "‚¨ÜÔ∏è Latest=$LATEST_VERSION ‚Üí Next=$APP_VERSION"
          else
            APP_VERSION="1.0.0"
            echo "üÜï No previous version, starting at $APP_VERSION"
          fi
          REGISTRY_URL=${REGISTRY_URL:-${{ vars.DOCKER_REGISTRY }}}
          IMAGE_TAG="$APP_VERSION"
          IMAGE_NAME="$REGISTRY_URL/${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local/$SERVICE_NAME:$IMAGE_TAG"
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ steps.set-build-info.outputs.build_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ steps.set-build-info.outputs.build_number }}
        with:
          version: latest
          oidc-provider-name: github-bookverse-checkout
          disable-job-summary: false
          disable-auto-build-publish: false
          disable-auto-evidence-collection: false
          oidc-audience: jfrog-github

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure pip to use JFrog virtual and probe
        run: |
          set -euo pipefail
          jf rt ping || true
          jf rt curl -XGET "/api/repositories/${{ vars.PROJECT_KEY }}-pypi-virtual" || true
          jf pipc --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          export PIP_DISABLE_PIP_VERSION_CHECK=1
          export PIP_NO_INPUT=1
          python -m pip --version
          python -m pip debug -v || true

      - name: Install dependencies
        run: |
          set -euo pipefail
          jf pipc --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          if ! jf pip install -r requirements.txt; then
            echo "‚ö†Ô∏è Falling back to public PyPI"
            pip install -r requirements.txt -i https://pypi.org/simple
          fi

      - name: Install test dependencies
        run: |
          set -euo pipefail
          jf pipc --repo-resolve "${{ vars.PROJECT_KEY }}-pypi-virtual"
          if ! jf pip install pytest pytest-cov httpx; then
            pip install -U pytest pytest-cov httpx -i https://pypi.org/simple
          fi

      - name: Run tests with coverage
        id: test-coverage
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          set -euo pipefail
          echo "Repo root: $GITHUB_WORKSPACE"
          python -c "import sys,os;print('PYTHONPATH=',os.environ.get('PYTHONPATH')); print('CWD=',os.getcwd()); print('sys.path[0]=',sys.path[0])"
          ls -la
          echo "üß™ Running tests with coverage"
          python -m pytest --maxfail=1 --disable-warnings -q \
                 --cov=app --cov-report=xml:coverage.xml --cov-report=html:htmlcov
          COV=$(python -c "import xml.etree.ElementTree as ET;root=ET.parse('coverage.xml').getroot();rate=float(root.get('line-rate') or 0.0);print(round(rate*100.0,1))")
          echo "coverage_percent=$COV" >> $GITHUB_OUTPUT

      - name: Install Helm CLI
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Export OpenAPI schema
        run: |
          set -euo pipefail
          python scripts/export_openapi.py

      - name: Package config bundle
        run: |
          set -euo pipefail
          chmod +x scripts/package_config_bundle.sh
          scripts/package_config_bundle.sh

      - name: Package Helm chart
        run: |
          set -euo pipefail
          mkdir -p dist
          helm package helm/checkout --version "$APP_VERSION" --destination dist

      - name: Collect artifacts into Build Info directory
        run: |
          set -euo pipefail
          mkdir -p dist/contracts
          cp contracts/order.created.schema.json dist/contracts/
          echo "Prepared dist/ with openapi.json, config bundle, contracts, helm chart"
      # Use OIDC-authenticated server from setup-jfrog-cli for uploads

      - name: Upload non-image artifacts (generic + helm) with build info
        continue-on-error: true
        run: |
          set -euo pipefail
          # Bind uploads to Build Info. Use --flat=true and explicit filenames to avoid including local 'dist/' in target path.
          jf rt u --project "${{ vars.PROJECT_KEY }}" --flat=true "dist/openapi.json" "${{ vars.PROJECT_KEY }}-generic-internal-local/checkout/${APP_VERSION}/openapi.json" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" || echo "‚ö†Ô∏è openapi upload failed; continuing"
          jf rt u --project "${{ vars.PROJECT_KEY }}" --flat=true "dist/contracts/order.created.schema.json" "${{ vars.PROJECT_KEY }}-generic-internal-local/checkout/${APP_VERSION}/contracts/order.created.schema.json" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" || echo "‚ö†Ô∏è contract upload failed; continuing"
          jf rt u --project "${{ vars.PROJECT_KEY }}" --flat=true "dist/checkout-config.bundle.tar.gz" "${{ vars.PROJECT_KEY }}-generic-internal-local/checkout/${APP_VERSION}/checkout-config.bundle.tar.gz" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" || echo "‚ö†Ô∏è config bundle upload failed; continuing"
          # Upload helm chart to typed Helm repo
          HELM_CHART_FILE="dist/checkout-${APP_VERSION}.tgz"
          jf rt u --project "${{ vars.PROJECT_KEY }}" --flat=true "$HELM_CHART_FILE" "${{ vars.PROJECT_KEY }}-helm-helm-internal-local/checkout/checkout-${APP_VERSION}.tgz" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" || echo "‚ö†Ô∏è helm chart upload failed; continuing"

      # Removed development-time credential probing; use a single, consistent auth method

      - name: Docker login, build and push image
        run: |
          set -euo pipefail
          jf docker login "${REGISTRY_URL}"
          # Build and push API image
          jf docker build --pull -t "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          jf docker push "$IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt dp --project "${{ vars.PROJECT_KEY }}" "$IMAGE_NAME" "${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"
          # Build and push worker image
          WORKER_IMAGE_NAME="$REGISTRY_URL/${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local/${SERVICE_NAME}-worker:$IMAGE_TAG"
          jf docker build --pull -t "$WORKER_IMAGE_NAME" -f Dockerfile.worker --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          jf docker push "$WORKER_IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt dp --project "${{ vars.PROJECT_KEY }}" "$WORKER_IMAGE_NAME" "${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"
          # Build and push migrations image
          MIG_IMAGE_NAME="$REGISTRY_URL/${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local/${SERVICE_NAME}-migrations:$IMAGE_TAG"
          jf docker build --pull -t "$MIG_IMAGE_NAME" -f Dockerfile.migrations --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          jf docker push "$MIG_IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt dp --project "${{ vars.PROJECT_KEY }}" "$MIG_IMAGE_NAME" "${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"
          # Optional: mock-payment image
          MOCK_IMAGE_NAME="$REGISTRY_URL/${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local/mock-payment:$IMAGE_TAG"
          jf docker build --pull -t "$MOCK_IMAGE_NAME" -f Dockerfile.mock-payment --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" .
          jf docker push "$MOCK_IMAGE_NAME" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt dp --project "${{ vars.PROJECT_KEY }}" "$MOCK_IMAGE_NAME" "${{ vars.PROJECT_KEY }}-$SERVICE_NAME-docker-internal-local" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      # Rely on Build Info as the source of truth; explicit registry checks removed

      - name: Publish Build Info
        run: |
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"

  create-application-version:
    needs: build-test-publish
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ github.event.repository.name }}-build-test-publish
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
        with:
          version: latest
          oidc-provider-name: github-bookverse-checkout
          disable-job-summary: false
          disable-auto-build-publish: false
          disable-auto-evidence-collection: false
          oidc-audience: jfrog-github

      - name: Configure JFrog CLI (admin)
        run: |
          jf c add bookverse-admin --interactive=false --url "${{ vars.JFROG_URL }}" --access-token "${{ secrets.JFROG_ADMIN_TOKEN }}"
          jf c use bookverse-admin
          jf c show

      - name: Create application version
        run: |
          set -euo pipefail
          SERVICE_NAME=checkout
          APPLICATION_KEY="bookverse-$SERVICE_NAME"
          APP_VERSION="${{ needs.build-test-publish.outputs.app_version }}"
          # Recompute build name/number to match build-test-publish job
          BUILD_NAME="${{ github.event.repository.name }}-build-test-publish"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          BUILD_INFO_REPO="${{ vars.PROJECT_KEY }}-build-info"

          if [[ -z "$APP_VERSION" ]]; then
            RESP=$(curl -sS -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" -H "Accept: application/json" \
              "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/")
            LATEST_VERSION=$(echo "$RESP" | jq -r '.versions[0].version // empty')
            if [[ -n "$LATEST_VERSION" && "$LATEST_VERSION" != "null" ]]; then
              MAJOR=$(echo "$LATEST_VERSION" | cut -d. -f1)
              MINOR=$(echo "$LATEST_VERSION" | cut -d. -f2)
              PATCH=$(echo "$LATEST_VERSION" | cut -d. -f3 | cut -d- -f1)
              APP_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
            else
              APP_VERSION="1.0.0"
            fi
          fi

          # If version already exists, treat as success
          CHECK_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -L \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION")
          if [[ "$CHECK_STATUS" == "200" ]]; then
            echo "‚úÖ Application version already exists: $APPLICATION_KEY@$APP_VERSION (skipping create)"
            exit 0
          fi

          APP_VERSION_PAYLOAD=$(cat << EOF
          {
            "version": "$APP_VERSION",
            "sources": {
              "builds": [
                {
                  "name": "$BUILD_NAME",
                  "number": "$BUILD_NUMBER",
                  "repository_key": "$BUILD_INFO_REPO",
                  "include_dependencies": true
                }
              ]
            }
          }
          EOF
          )

          RESP_FILE=$(mktemp)
          STATUS=$(curl -sS -L -o "$RESP_FILE" -w "%{http_code}" -X POST \
            "${{ vars.JFROG_URL }}/apptrust/api/v1/applications/$APPLICATION_KEY/versions/?async=false" \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -d "$APP_VERSION_PAYLOAD")
          echo "HTTP $STATUS"
          if [[ "$STATUS" -eq 409 ]]; then
            echo "‚úÖ Version already exists (409) ‚Äî proceeding"
          elif [[ "$STATUS" -lt 200 || "$STATUS" -ge 300 ]]; then
            echo "‚ùå Failed to create application version; response body:" >&2
            cat "$RESP_FILE" >&2 || true
            rm -f "$RESP_FILE"
            exit 1
          fi
          rm -f "$RESP_FILE"
          echo "‚úÖ Application version created: $APPLICATION_KEY@$APP_VERSION"
